# Practice_4.1-4.3
# Вариант 11
# 1. Пример кода на Python
Задача: реализовать простой генетический алгоритм для максимизации функции.
# 2. Подробное описание работы алгоритма по шагам

ШАГ 1: Инициализация популяции

· Создается начальная популяция из случайных двоичных строк
· Каждая строка (хромосома) представляет возможное решение
· Длина хромосомы определяет точность представления числа
· Пример: хромосома [1,0,1,1,0,0,1,0,1,0] кодирует число в диапазоне [0, 10]

ШАГ 2: Декодирование хромосом

· Каждая двоичная хромосома преобразуется в вещественное число
· Формула: x = x_min + (decimal / (2^L - 1)) * (x_max - x_min)
· где decimal - десятичное значение двоичного числа
· L - длина хромосомы

ШАГ 3: Оценка приспособленности

· Для каждого значения x вычисляется целевая функция
· f(x) = -(x - 5)² + 25
· Чем ближе x к 5, тем выше значение функции (приспособленность)

ШАГ 4: Отбор родителей

· Используется метод пропорционального отбора (рулетка)
· Вероятность выбора особи пропорциональна ее приспособленности
· Особи с большей приспособленностью имеют больше шансов стать родителями

ШАГ 5: Кроссовер (скрещивание)

· С вероятностью crossover_rate происходит обмен частями хромосом
· Выбирается случайная точка разрыва
· Пример:
  · Родитель1: [1,0,1,1,0,0,1,0,1,0]
  · Родитель2: [0,1,0,1,1,0,0,1,0,1]
  · Потомок: [1,0,1,1,1,0,0,1,0,1]

ШАГ 6: Мутация

· С вероятностью mutation_rate каждый бит инвертируется
· Добавляет разнообразие в популяцию
· Помогает избежать застревания в локальных оптимумах

ШАГ 7: Формирование нового поколения

· Новое поколение полностью заменяет старое
· Процесс повторяется заданное количество раз

# 3. Оценка временной сложности

Общая временная сложность: O(G × P × L)

где:

· G - количество поколений
· P - размер популяции
· L - длина хромосомы

# 4. Подробное объяснение временной сложности

Разберем сложность каждой операции:

1. Инициализация популяции:
[[random.randint(0, 1) for _ in range(L)] for _ in range(P)]
· Создание одной хромосомы: O(L)
· Создание P хромосом: O(P × L)

2. Декодирование хромосом (каждое поколение):
[decode_chromosome(chrom, x_min, x_max) for chrom in population]
· Декодирование одной хромосомы: O(L) (проход по всем битам)
· Декодирование P хромосом: O(P × L)

3. Вычисление приспособленности:
[fitness_function(x) for x in decoded]
· Вычисление одной функции: O(1) (простая арифметика)
· Вычисление для P особей: O(P)

4. Отбор родителей:
select_parent(population, fitnesses)  # вызывается 2P раз за поколение
· Один отбор: O(P) (в худшем случае)
· Всего отборов: 2P × O(P) = O(P²)

5. Кроссовер:
crossover(parent1, parent2, crossover_rate)  # P раз за поколение
· Один кроссовер: O(L) (копирование хромосом)
· Всего: O(P × L)

6. Мутация:
mutate(child, mutation_rate)  # 2P раз за поколение
· Одна мутация: O(L) (проверка каждого бита)
· Всего: O(2P × L) = O(P × L)

Суммарная сложность одного поколения: O(P × L) + O(P) + O(P²) + O(P × L) + O(P × L) = O(P² + P × L)
Так как обычно P > L, упрощаем до: O(P² + P × L) ≈ O(P²)
Общая сложность алгоритма: O(G × P²)
На практике: При P=20, G=50, L=10:
· Теоретическая сложность: O(50 × 20²) = O(20,000)
· Реальное количество операций: ~50 × (20×10 + 20 + 400 + 20×10) ≈ 50 × 820 = 41,000 операций

# 5. Данные для ввода и пример вывода
Вводные данные для тестирования:
Размер популяции: 20
Количество поколений: 50
Вероятность кроссовера: 0.8
Вероятность мутации: 0.1
Длина хромосомы: 10

Вывод:
Лучшее решение: x = 4.995112
Максимальное значение: f(x) = 24.999976
Истинный максимум: x = 5.000000, f(x) = 25.000000
Погрешность: 0.00002389

# 6. Вопрос 11
Имитация отжига
Объясните принцип работы метаэвристики "Имитация отжига" и роль параметра
температуры.

Имитация отжига — это вероятностный метаэвристический алгоритм, основанный на физическом процессе отжига металлов, когда материал нагревается и медленно охлаждается для достижения состояния с минимальной энергией.

Принцип работы:

· Алгоритм, имитирующий процесс отжига металлов
· Начинает со случайного решения и постепенно его улучшает
· Может временно принимать ухудшения, чтобы избежать локальных оптимумов
· Использует критерий Метрополиса: P(принять) = exp(-ΔE/T)

Роль температуры:

· Высокая T (начало): принимает большинство решений, активно исследует пространство
· Средняя T: баланс между исследованием и использованием
· Низкая T (конец): работает как жадный алгоритм, только улучшает решение

Ключевая идея:
Температура управляет вероятностью принятия худших решений:

· При большой T - высокий шанс выйти из локального оптимума
· При малой T - точная настройка найденного решения

Процесс: Нагрев → Медленное охлаждение → "Закаливание" оптимального решения





















